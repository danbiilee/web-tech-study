# 리덕스의 3가지 규칙

## 1. 하나의 애플리케이션에는 하나의 스토어만
하나의 애플리케이션에는 단 하나의 스토어를 만들어서 사용한다. 여러 개의 스토어를 사용하는 것은 가능하기는 하나, 개발도구를 화용하지 못하게 되므로 권장되지는 않는다. 


## 2. 상태는 읽기전용이다
리액트에서 `state`를 업데이트할 때는 기존의 상태는 건드리지 않고 새로운 상태를 생성하여 업데이트를 해야 한다. 즉 **불변성을 지켜야 한다**.  그 때문에 `setState`를 사용하고, 배열을 업데이트할 때 `push`가 아닌 `concat` 함수를 사용하고, 객체를 업데이트할 때에도 `Object.assing`을 사용하거나 speard 연산자(`...`)를 사용하는 것이다.  

리덕스에서도 마찬가지이다. 불변성을 유지하며 상태 업데이트를 하면, 개발자 도구를 통해 뒤로 돌릴 수도 있고 다시 앞으로 돌릴 수도 있다. 

리덕스에서 불병성을 유지해야 하는 이유는 내부적으로 데이터가 변경되는 것을 감지하기 위해 [shallow equality](https://redux.js.org/faq/immutable-data#how-redux-uses-shallow-checking) 검사를 하기 때문이다. 객체의 변화를 감지할 때 겉핥기 식으로 비교를 해 좋은 성능을 유지할 수 있는 것이다. 

우리는 이번 튜토리얼에서 Immutable.js 혹은 Immer.js를 사용해 불변성을 유지하며 상태를 관리하는 방법에 대해 다루게 된다. 

> 참고 [리액트의 불변함, 컴포넌트에서 Immutable.js 사용하기](https://velopert.com/3486)



## 3. 리듀서는 순수한 함수여야 한다
변화를 일으키는 함수 리듀서는 순수한 함수여야 한다. 

리듀서 함수란? 
- 리듀서 함수는 이전 상태와 액션 객체를 파라미터로 받는다.
- 이전 상태는 절대로 건들지 않고, 변화를 일으킨 새로운 상태를 만들어 반환한다.
- 똑같은 파라미터로 호출된 리듀서 함수는 **언제나** 똑같은 결과값을 반환해야 한다. 

위 3가지 사항을 따른 리듀서 함수는 동일한 인풋이라면 언제나 동일한 아웃풋이 있는 순수한 함수가 되는 것이다.

그런데 일부 로직들 중 실행할 때마다 다른 결과값이 나타날 수도 있다. `new Date()`를 사용한다든지 랜덤한 숫자를 생성한다든지, 혹은 네트워크에 요청을 한다든지... 그러한 작업들은 결코 순수하지 않은 작업이므로, 리듀서 함수의 바깥에서 처리해줘야 한다. 그 작업을 위해 `리덕스 미들웨어`를 사용하는데 이는 추후에 다루게 될 것이다. 

